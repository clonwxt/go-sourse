# 非类型安全指针

为了安全起见，Go指针在使用上相对于C指针有很多限制。 通过施加这些限制，Go指针保留了C指针的好处，同时也避免了C指针的危险性。

在基础篇中，我们介绍了Go指针是有类型限制的: *T, 这种具有类型限制的指针我们称为类型安全的指针,在使用上有些限制，比如:

1.Go指针不支持算术运算

```go
str := "pointer_test"
a := &str
// a++ a-- 是不合法的
```

2.一个指针类型的值不能被随意转换为另一个指针类型

```go
```

3.一个指针值不能被赋值给其它任意类型的指针值

```go
```

unsafe标准库包中提供的非类型安全指针（unsafe.Pointer）机制可以被用来打破上述Go指针的安全限制。 unsafe.Pointer类型类似于C语言中的void*。 但是，通常地，非类型安全指针机制不推荐在Go日常编程中使用

## 关于unsafe标准库包

## 注意事项

### 非类型安全指针值是指针但uintptr值是整数

### 不再被使用的内存块的回收时间点是不确定的

### 一个值的地址在程序运行中可能改变

### 一个值的生命范围可能并没有代码中看上去的大

### *unsafe.Pointer是一个类型安全指针类型

## 正确使用非类型安全指针

unsafe标准库包的文档中列出了[六种非类型安全指针的使用模式](https://golang.google.cn/pkg/unsafe/#Pointer)

### 使用模式一：将类型*T1的一个值转换为非类型安全指针值，然后将此非类型安全指针值转换为类型*T2

### 使用模式二：将一个非类型安全指针值转换为一个uintptr值，然后使用此uintptr值

### 将一个非类型安全指针转换为一个uintptr值，然后此uintptr值参与各种算术运算，再将算术运算的结果uintptr值转回非类型安全指针

### 使用模式四：将非类型安全指针值转换为uintptr值并传递给syscall.Syscall函数调用

### 将reflect.Value.Pointer或者reflect.Value.UnsafeAddr方法的uintptr返回值立即转换为非类型安全指针

### 使用模式六：将一个reflect.SliceHeader或者reflect.StringHeader值的Data字段转换为非类型安全指针，以及其逆转换

